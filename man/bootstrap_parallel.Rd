% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel_boot.R
\name{bootstrap_parallel}
\alias{bootstrap_parallel}
\title{Parallel wrapper for bootstrap functions (chunked by workers)}
\usage{
bootstrap_parallel(
  ...,
  R = 1000,
  k = NULL,
  BOOT.FUN = modsem::bootstrap_modsem,
  future.seed = TRUE
)
}
\arguments{
\item{...}{arguments forwarded to \code{BOOT.FUN}, e.g., \code{bootstrap_modsem}}

\item{R}{Integer. Total number of bootstrap replicates.}

\item{k}{Integer. Number of chunks (defaults to \code{future::nbrOfWorkers()}).}

\item{BOOT.FUN}{Function. The bootstrap function to be wrapped.}

\item{future.seed}{Logical or integer. Passed to \code{future.apply::future_lapply()}
as \code{future.seed} for reproducible RNG. Default \code{TRUE}.}
}
\value{
A matrix formed by \code{rbind}-ing the chunk results. Column names
are taken from the first non-empty chunk when available.
}
\description{
Runs a non-parallel bootstrap function in parallel by splitting the total
number of replicates \code{R} into \code{k} chunks and evaluating each chunk
in a separate future. Verbose output is disabled in all chunks. Results are
combined with \code{rbind}.
}
\examples{
\dontrun{
# You might need to install these
library(future)
library(future.apply)
library(modsem)
library(modsemTools)

plan(multisession, workers = 8)  # multicore also works, but only on Linux/MacOs

m1 <- '
# Outer Model
  X =~ x1 + x2 + x3
  Z =~ z1 + z2 + z3
  Y =~ y1 + y2 + y3

# Inner Model
  Y ~ X + Z + X:Z
'

fit <- modsem(m1, data = oneInt, method = "lms", n.threads = 1L)
boot <- bootstrap_parallel(
  model = fit,
  R = 1000L,
  FUN = "coef"
)
}
}
